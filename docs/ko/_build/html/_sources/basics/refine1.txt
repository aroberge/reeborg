단계적 정제: 1부
===================

여러 부분으로 나뉜 수업에서, 점증하는 복잡성을 가진 문제를 해결하는 온전한 프로그램을 작성할 것이다.

각 수업에서, 저자가 한가지 실수가 포함된 점정 해법을 제시한다. 다음 수업으로 나아가기 전에 찾아보기 바란다.

단순한 문제
----------------

간단한 프로그램엣 출발한다: 리보그가 세상을 주위를 **한번** 돌아, 출발 지점으로 되돌아 와서 멈춘다.
**Around 1** 세상을 선택한다. ``front_is_clear()`` 테스트를 소개했을 때, 전에 동일한 프로그램을 작성했다. 
여기 출발점에서 리보그가 적어도 비퍼 하나를 지니고 다닌다고 가정하는 해법의 개요가 나와 있다:

#. 출발점(도착점)을 표식으로 비퍼를 내려놓는다.
#. 벽을 마주할 때까지 계속 전진한다.
#. 벽에 마주할 때 왼쪽으로 회전한다.
#. 내려놓은 토큰을 발견할 때까지 2, 3번 단계를 반복한다.

상기 알고리즘에 관해서 생각할 시간을 천천히 갖는다. 그리고 나서 코드에 나온 다음 해법을 고려한다::

    put()
    while not object_here():
        if front_is_clear():
            move()
        else:
            turn_left()

.. topic:: 여러분 차례!

    시간을 갖고, 프로그램을 실행해보기 전에, 상기 프로그램이 리보그에게 무엇을 지시하는지에 관해서 생각해 본다.
    제안된 해법에 문제를 발견할 수 있는가?

.. hint::

    .. code-block:: python

        put()
        move()
        while not object_here():
            if front_is_clear():
                move()
            else:
                turn_left()