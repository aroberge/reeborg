
단계적 정제: 2부
===================

1부의 마지막에 우리가 직면한 문제의 원인이 다음에 있다:
토큰을 내려놓는다. 앞으로 이동하기 전에 토큰이 있지 않은지를 확인하는 테스트를 한다. 
토크에 있어서, ``while`` 루프 명령문에 들어갈 기회가 전혀 없다. 
아마도 반복 명령문을 실행하기 전에 ``move()`` 명령문을 아래와 같이 추가하여 수정한다.


    put()
    move()
    while not object_here():
        if front_is_clear():
            move()
        else:
            turn_left()

.. topic:: 시도해 보기!

   다음으로 넘어가기 전에, 상기 프로그램을 확인한다.

그다지 단순하지 않는 세상
--------------------------

좀더 복잡한 **Around 2** 세상에 작성한 프로그램을 시도해 보자.

.. note::

    다음을 포함하는 것을 잊지마세요::

        from library import turn_right

프로그램을 실행하면, 결과는 우리가 원하는 것이 정확히 아니다: 
리보그가 지름길을 택해서 가고, 벽을 따라 움직이지는 않는다.
문제는 리보그가 벽을 따라 움직일 때 단지 앞으로 전진만 하거나, 왼쪽으로만 회전하는 것을 가정했다: 
리보그가 오른쪽으로 회전하는 상황에 대해서는 고려를 전혀 하지 않았다. 
리보그에게 필요한 것은 첫째 오른쪽에 여전히 벽이 있는지를 확인하는 것이다. 
만약 벽이 없다면, 리보그가 오른쪽으로 회전을 해야만 한다. 
오른쪽으로 회전하려고 *시도하는* 수정된 프로그램이 있다::

    put()
    move()
    while not object_here():
        if right_is_clear():
            turn_right()
        elif front_is_clear():
            move()
        else:
            turn_left()

.. topic:: 여러분 차례!

    정상적으로 잘 동작합니까? 
    결정을 내리기 위해서 주의 깊게 읽어보세요. 
    그리고 나서, 프로그램을 실행해서 여러분의 의견을 확인하기 위해 직접 시도해 보거나, 
    본인이 생각하는 적절한 변경을 한다.
