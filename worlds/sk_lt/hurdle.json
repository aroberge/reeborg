{
    "robots": [
    {
      "x": 1,
      "y": 1,
      "_prev_x": 1,
      "_prev_y": 1,
      "_prev_orientation": 0,
      "objects": {},
      "_orientation": 0,
      "_is_leaky": true,
      "_trace_history": [],
      "_trace_style": "default",
      "_trace_color": "seagreen",
      "__id": 4,
      "model": "classic",
      "possible_initial_positions": [
        [
          1,
          1
        ]
      ]
    }
  ],
  "description": [
    "<h1>Paskutinės šokinėjimo varžybos</h1>",
    "<p>Robotukas vėl šokinėja per kliūtis. Šį kartą ",
    "kliūtys gali būti bet kokio aukščio ir be kokio pločio. Robotukui ",
    "reikia šokinėti per jas kol pasieks vėliavėlę.</p>",
    "DIFFICULTY3"
  ],
  "small_tiles": false,
  "rows": 10,
  "cols": 12,
  "background_image": "worlds/images/stadium.png",
  "post": [
    "if not RUR.check_path(RUR.public['path']):",
    "",
    "    # The program was not a valid solution ... ",
    "    # Let's provide feedback in a single visible frame",
    "    recording(False)",
    "    # let's make the background picture less visible",
    "    # by covering the entire background with semi-transparent black tiles",
    "    RUR.fill_background('rgba(0, 0, 0, 0.6)')",
    "    # We also show the path again",
    "    RUR.show_path(RUR.public['path'], 'orange');",
    "    ",
    "    recording(True)",
    "    # finally, we throw an error to end the execution",
    "    raise RUR.ReeborgError(\"Nebuvo sekama reikiamu keliu.\")",
    "    "
  ],
  "onload": [
    "# python version to generate random hurdle world",
    "",
    "import random",
    "",
    "width = random.randrange(8, 14)",
    "height = 10 #random.randrange(8, 14)",
    "RUR.set_world_size(width, height+1)",
    "",
    "RUR.public['path'] = [[1, 1]]",
    "RUR.set_model('light blue')   # robot with better contrast",
    "RUR._set_trace_color_('cyan') # path colour with better contrast",
    "",
    "def place_walls(x, wall_width):",
    "    wall_height = random.randrange(1, height)",
    "    for y in range(1, wall_height+1):",
    "        RUR.add_wall(\"west\", x, y)",
    "        if [x-1, y] != RUR.public['path'][-1]:",
    "            RUR.public['path'].append([x-1, y])",
    "",
    "    # Reeborg must go higher than the wall",
    "    RUR.public['path'].append([x-1, wall_height+1])",
    "",
    "    # across ",
    "    for i in range(x, x+wall_width):  # skipped if wall_width == 0",
    "        RUR.add_wall(\"north\", i, y)",
    "        RUR.public['path'].append([i, y+1])",
    "        ",
    "    x += wall_width",
    "    RUR.public['path'].append([x, y+1])",
    "",
    "    #down",
    "    for y in range(wall_height, 0, -1):",
    "        RUR.public['path'].append([x, y])",
    "        if wall_width > 0:",
    "            RUR.add_wall(\"west\", x, y)",
    "",
    "",
    "x = 2",
    "",
    "while x < width:",
    "    if random.randrange(1,100) < 70:",
    "        # how wide should it be? tend toward zero width",
    "        if random.randrange(1,100) < 30:",
    "            wall_width = random.randrange(1, 4)",
    "            # don't go off edge",
    "            if wall_width + x >= width:",
    "                wall_width = width - x - 1",
    "        else:",
    "            wall_width = 0",
    "        place_walls(x, wall_width)",
    "        x += wall_width + 1",
    "    else:",
    "        RUR.public['path'].append([x, 1])",
    "        x += 1",
    "",
    "RUR.public['path'].append([width, 1])",
    "",
    "# put goal at end of world",
    "RUR.add_final_position(\"racing_flag\", width, 1)",
    "",
    "# We show the desired path very clearly;  in the",
    "# Pre editor, we can set it to be less visible",
    "RUR.show_path(RUR.public['path'], 'white');",
    ""
  ]
}