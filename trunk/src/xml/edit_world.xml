<script>
var user_world = {};

$("#cmd-input").keyup(function (e) {
    if (e.keyCode == 13) {
        try {
            eval($("#cmd-input").val());
            $("#cmd-input").val("")
        } catch (e) {
            $("#cmd-result").html(e.message);
        }
        copy();
    }
});

function save_world(name){
    if (localStorage.getItem("user_world:" + name) !== null){
        alert("Name already exist; will not save.");
        return;
    }
    localStorage.setItem("user_world:"+ name, JSON.stringify(user_world));
    $('#select_world').append( $('<option style="background-color:#ff9" selected="true"></option>'
                              ).val("user_world:" + name).html(name));
    _update("saved world");
}

function delete_world(name){
    if (localStorage.getItem("user_world:" + name) === null){
        alert("No such world.");
        return;
    }
    localStorage.removeItem("user_world:" + name);
    $("select option[value='" + "user_world:" + name +"']").remove();
    RUR.controls.deselect();
    _update("deleted world");
    user_world = {};
}

function _update(message) {
    RUR.world.import_(JSON.stringify(user_world));
    RUR.world.reset();
    RUR.visible_world.reset();
    $("#cmd-result").html(message);
}

function copy(){
    $("#output-pre").html(JSON.stringify(user_world, null, '   '));
}

function remove_robot() {
    delete user_world.robots;
    _update("removed robot");
}
function add_robot(x, y, orientation, tokens){
    var robot = {};
    robot.x = x || 1;
    robot.y = y || 1;
    robot.orientation = orientation || 0;
    robot.tokens = tokens || 0;
    user_world.robots = [robot];
    _update("added or changed robot");
}

function _ensure_key_exist(obj, key){
    if (obj[key] === undefined){
        obj[key] = {};
    }
}

function toggle_wall(x, y, orientation){
    var index, coords;
    if (!(orientation ==="east" || orientation === "north")){
        $("#cmd-result").html("invalid orientation:" + orientation);
        return;
    }
    coords = x + "," + y;
    _ensure_key_exist(user_world, "walls");
    if (user_world.walls[coords] === undefined){
        user_world.walls[coords] = [orientation];
        _update("wall added");
    } else {
        index = user_world.walls[coords].indexOf(orientation);
        if (index === -1) {
            user_world.walls[coords].push(orientation);
            _update("wall added")
        } else {
            user_world.walls[coords].remove(index);
            if (user_world.walls[coords].length === 0){
                delete user_world.walls[coords];
                if (Object.keys(user_world.walls).length === 0){
                    delete user_world.walls;
                }
            }
            _update("wall removed");
        }
    }
}

function set_tokens(x, y, nb_tokens) {
    if (user_world.shapes !== undefined && user_world.shapes[x + "," + y] !== undefined){
        $("#cmd-result").html("shape here; can't put tokens");
        return;
    }
    _ensure_key_exist(user_world, "tokens");
    if (nb_tokens > 0) {
        user_world.tokens[x + "," + y] = nb_tokens;
    } else {
        delete user_world.tokens[x + "," + y];
        if (Object.keys(user_world.tokens).length === 0){
            delete user_world.tokens;
        }
    }
    _update("updated tokens");
}

function toggle_shape(x, y, shape){
    if (!(shape === "star" || shape === "square" || shape === "triangle")){
        $("#cmd-result").html("unknown shape: " + shape);
        return;
    }
    if (user_world.tokens !== undefined && user_world.tokens[x + "," + y] !== undefined){
        $("#cmd-result").html("tokens here; can't put a shape");
        return;
    }
    _ensure_key_exist(user_world, "shapes");
    if (user_world.shapes[x + "," + y] === shape) {
        delete user_world.shapes[x + "," + y];
        if (Object.keys(user_world.shapes).length === 0){
            delete user_world.shapes;
        }
    } else {
        user_world.shapes[x + "," + y] = shape;
    }
    _update("updated shapes");
}

function set_goal_position(x, y){
    _ensure_key_exist(user_world, "goal");
    if (x >0  && y >0){
        user_world.goal.position = {"x": x, "y": y};
        _update("updated position goal");
    } else {
        if (user_world.goal.position !== undefined){
            delete user_world.goal.position;
            if (Object.keys(user_world.goal).length === 0){
                delete user_world.goal;
            }
        }
        _update("No position goal")
    }
}

function set_goal_orientation(orientation){
    _ensure_key_exist(user_world, "goal");
    if ([0, 1, 2, 3].indexOf(orientation) !== -1){
        user_world.goal.orientation = orientation;
        _update("updated orientation goal");
    } else {
        if (user_world.goal.orientation !== undefined){
            delete user_world.goal.orientation;
            if (Object.keys(user_world.goal).length === 0){
                delete user_world.goal;
            }
        }
        _update("No orientation goal")
    }
}

function set_goal_tokens(x, y, tokens){
    _ensure_key_exist(user_world, "goal");
}
function set_goal_wall(x, y, orientation){
    _ensure_key_exist(user_world, "goal");;
}
function set_goal_shape(x, y, shape){
    _ensure_key_exist(user_world, "goal");
}


function duplicate() {
    user_world = JSON.parse(RUR.world.json_world_string);
    _update("duplicated world");
}
</script>

<h2>Create your own worlds!</h2>

<p>Suggestion: close the Content and Editor panels, and open the Diary.
    Start with an existing world selected and duplicate it. Remember to save.</p>

<p>Command: <input type="text" id="cmd-input"> <span id="cmd-result"></span></p>
<ul><li><code> duplicate()</code>: duplicates the currently selected world.</li>
    <li><code>save_world("name")</code>: saves the current world (uses html localStorage)</li>
    <li><code>delete_world("name")</code>: deletes previously saved world.</li>
<li><code>add_robot(x, y, orientation, tokens)</code>: adds or replace a robot; only
one robot is allowed.  Optional arguments are, in order: x, y, orientation (0 means East, 1
means North, etc.), tokens (positive integer or use any string, like "infinite" [self-documenting!]
for a robot that carries an unlimited number of tokens).  Default values: 1, 1, 0, 0. </li>
<li><code>remove_robot()</code>: remove existing robot.</li>
<li><code>toggle_wall(x, y, direction)</code> where direction is one of "east" or "north".</li>
<li><code>set_tokens(x, y, nb_tokens</code> sets the number of tokens at a given location.</li>
<li><code>toggle_shape(x, y, shape)</code> puts a shape (or remove it) at a given location.
Allowed shapes: "star", "triangle", "square". Only one shape per location. </li>
<li><code>set_goal_position(x,y)</code>: sets the goal position; choose x=y=0 to remove
this goal.</li>
<li><code>set_goal_orientation(orientation)</code>: sets the goal orientation
    (0=East, 1=North, 2=West, 3=South);
choose a non-allowed value to remove this goal.</li>
<li><code>copy()</code>: if needed, outputs a json string representing the world in Reeborg's diary;
this is done automatically whenever the world is edited</li></ul>
