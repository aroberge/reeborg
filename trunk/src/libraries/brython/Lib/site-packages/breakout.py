from math import pi
from browser import doc, html
from browser.timer import set_timeout, clear_timeout
from javascript import JSConstructor


'''
todo
1. Levels
2. types of bricks
                        x. Score
4. high score : player name
5. sound
 - collision brick
 - collision paddle
 - win
 - lose 
 - break brick 
6. Better collision
7. background image
                    x. Better speed
9. start/restart
                    x. multiple lives
11. image for balls
                    x. show instruction only when not playing
13. organize code 
                        x. Player 
'''


class World(object):
    '''Container for the various canvases used to draw the game'''
    def __init__(self):
        self.game_canvas = doc["game-canvas"]
        self.game_canvas_ctx = self.game_canvas.getContext('2d')
        self.width = self.game_canvas.width
        self.height = self.game_canvas.height

        main_canvas = doc["main-canvas"]
        self.main_canvas_ctx = main_canvas.getContext("2d")

        background_canvas = doc["background-canvas"]
        self.background_canvas_ctx = background_canvas.getContext("2d")
        
        far_background_canvas = doc["far-background-canvas"]
        self.far_background_canvas_ctx = far_background_canvas.getContext("2d")
        self.far_background_canvas_ctx.globalAlpha = 0.5  # making transparent
        self.far_background_image = html.IMG(src = "src/images/code_background.png")
        
        # html canvas image loading workaround to ensure that image is available
        def on_load(*arg):
             self.draw_far_background()
        self.far_background_image.onload = on_load


    def clear_main(self):    
        '''Clears main canvas: the one with moving objects'''
        self.main_canvas_ctx.clearRect(0, 0, self.width, self.height)

    def clear_game(self):    
        '''Clears the game canvas: the one that is "clickable" and where
           the textual presentation is displayed as an overlay.'''
        self.game_canvas_ctx.clearRect(0, 0, self.width, self.height)

    def clear_background(self):   
        '''Clears the background canvas: where the bricks are drawn''' 
        self.background_canvas_ctx.clearRect(0, 0, self.width, self.height)

    def clear_far_background(self):    
        '''Clears the far background: where the background image is drawn.'''
        self.far_background_canvas_ctx.clearRect(0, 0, self.width, self.height)

    def clear_all(self):
        '''Clears all the drawing canvases'''
        self.clear_main()
        self.clear_game()
        self.clear_background()
        self.clear_far_background()

    def draw_far_background(self):
        self.far_background_canvas_ctx.drawImage(self.far_background_image, 0, 0)
        

world = World() 

class Player(object):

    def __init__(self, lives):
        self.lives = lives
        self.lost_life = False

    def lose_ball(self):
        self.lives -= 1
        self.lost_life = True

player = Player(3)


class GameInfo(object):
    def __init__(self):
        self.ctx = world.game_canvas_ctx

    def show_game_over(self):
        global pause
        pause = True
        self.ctx.font = "100px sans-serif"
        self.ctx.fillStyle = "red"
        self.ctx.fillText("Game over!", 50, 300)

    def show_game_win(self):
        global pause
        pause = True
        self.ctx.font = "100px sans-serif"
        self.ctx.fillStyle = "green"
        self.ctx.fillText("You win!", 50, 300)   

    def write_help(self):
        self.ctx.font = "30px sans-serif"
        self.ctx.fillStyle = "rgba(100, 100, 100, 0.6)"
        self.ctx.fillRect(0, 0, world.width, world.height)
        self.ctx.fillStyle = "blue"
        self.ctx.fillText("S to start the animation", 50, 100)
        self.ctx.fillText("P to pause the animation", 50, 150)
        self.ctx.fillText("Q to quit: click BEFORE editing!", 50, 200)

info = GameInfo()


class Score(object):

    def __init__(self):
        self.score = 0
        self.ctx = world.game_canvas_ctx
        self.score_x = world.game_canvas.width - 50
        self.lives_x = 30
        self.ball_radius = 10
        self.y = 15
        self.reserved_height = 30

    def update(self, info):
        self.score += 1
        if info == "hit paddle":
            self.score += 10
        elif info == "hit wall":
            self.score -= 1   # penalize slow play
        elif info == "hit brick":
            self.score += 100
        elif info == "break brick":
            self.score += 1000
        elif info == "win":
            self.score += 10000
        elif info == "lose ball":
            self.score -= 1000
        else:
            pass

    def draw(self):
        # prepare area for drawing
        self.ctx.clearRect(0, 0, world.game_canvas.width, self.reserved_height)
        self.ctx.fillStyle = "black"
        self.ctx.fillRect(0, 0, world.game_canvas.width, self.reserved_height)
        # draw score
        self.ctx.font = "15px sans-serif"
        self.ctx.fillStyle = "white"
        self.ctx.fillText(str(self.score), self.score_x, self.y)
        # draw lives
        self.ctx.fillStyle = ball.color
        for life in range(player.lives):
            self.ctx.beginPath()
            self.ctx.arc(self.lives_x + life*4*self.ball_radius, self.y, self.ball_radius, 0, pi*2)
            self.ctx.closePath()
            self.ctx.fill() 

score = Score()

class Ball(object):
    ''' ball docstring'''
    def __init__(self, x, y, radius=10, color='red', dx=5, dy=5):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
        self.dx = dx
        self.dy = dy
        self.speed = (self.dx**2 + self.dy**2)**0.5
        self.max_speed = 2*self.speed
        self.calculate_bounding_box()
        self.ctx = world.main_canvas_ctx
    
    def draw(self):
        ''' draw doc'''
        self.ctx.fillStyle = self.color
        self.ctx.beginPath()
        self.ctx.arc(self.x+self.radius, self.y+self.radius, self.radius, 0, pi*2)
        self.ctx.closePath()
        self.ctx.fill()        
     
    def move(self):
        self.x += self.dx
        self.y += self.dy

    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + 2*self.radius
        self.y_max = self.y + 2*self.radius
    
    def handle_hit_with(self, other):
        if isinstance(other, Paddle) and self.dy > 0:
            self.y -= self.dy
            self.dy = -self.dy
            offset = self.x - (paddle.x + paddle.width/2)
            self.dx = 10*offset/paddle.width
            speed = (self.dx**2 + self.dy**2)**0.5
            self.dx *= (self.speed/speed)
            self.dy *= (self.speed/speed)
            score.update("hit paddle")
        elif isinstance(other, Brick):
            self.y -= self.dy
            self.dy = -self.dy
            if self.speed < self.max_speed:
                self.speed *= 1.05
                self.dx *= 1.05
                self.dy *= 1.05
            score.update("hit brick")
            
    def overlaps_with(self, other):
        if (    ((self.x_min < other.x_min < self.x_max ) or 
                 (other.x_min < self.x_min < other.x_max))
            and ((self.y_min < other.y_min < self.y_max) or 
                 (other.y_min < self.y_min < other.y_max)) ):
            return True
        return False 
        
    def stay_in_world(self):
        if self.x < 0 and self.dx < 0:
            self.dx = -self.dx
            self.x = -self.x
            score.update("hit wall")
        elif self.x > world.width - 2*self.radius and self.dx > 0:
            self.dx = -self.dx
            self.x = 2*(world.width - 2*self.radius) - self.x
            score.update("hit wall")
        if self.y < score.reserved_height and self.dy < 0:
            self.dy = -self.dy
            self.y =  2*score.reserved_height - self.y
            score.update("hit wall")
        elif self.y > world.height - 2*self.radius and self.dy > 0:
            score.update("lose ball")
            if DEBUG:
                self.dy = -self.dy
                self.y = 2*(world.height - 2*self.radius) - self.y
            else:
                player.lose_ball()
        self.calculate_bounding_box()


class Paddle(object):
    
    def __init__(self, x, y, width=80, height=10, color="blue", dx=7):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.dx = dx
        self.calculate_bounding_box()
        self.ctx = world.main_canvas_ctx
    
    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + self.width
        self.y_max = self.y + self.height
        
    def draw(self):
        self.ctx.fillStyle = self.color
        self.ctx.fillRect(self.x, self.y, self.width, self.height)

    def move(self, direction):
        if direction == "left":
            self.dx = - abs(self.dx)
        elif direction == "right":
            self.dx = abs(self.dx)
        self.x += self.dx
        keep_paddle_in()
        self.calculate_bounding_box()
    
    def mouse_move(self, ev):
        x, y = get_mouse_position(ev)
        self.x = x
        keep_paddle_in()
        self.calculate_bounding_box()
       
        
class Brick(object):
    
    def __init__(self, x, y, width=60, height=30, color="green"):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.calculate_bounding_box()
        self.is_hittable = True
        self.is_visible = True
        self.ctx = world.background_canvas_ctx
    
    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + self.width
        self.y_max = self.y + self.height
        
    def draw(self):
        if self.is_visible:
            self.ctx.fillStyle = self.color
            self.ctx.fillRect(self.x, self.y, self.width, self.height)
        else:
            self.ctx.clearRect(self.x, self.y, self.width, self.height)

    def handle_hit_with(self, other):
        if isinstance(other, Ball):
            self.is_visible = False
            self.is_hittable = False
            self.draw()
            score.update("break brick")


def keep_paddle_in():
    if paddle.x < 0:
        paddle.x = 0
    elif paddle.x + paddle.width > world.width:
        paddle.x = world.width - paddle.width

def handle_keydown_events(ev):
    global pause, _id
    _id = None
    warn = True
    if ev.keyCode == 37:   # left arrow
        paddle.move("left")
        warn = False
    if ev.keyCode == 38:   # up arrow
        ball.dx *= 1.1
        ball.dy *= 1.1
        ball.speed *= 1.1
        ball.max_speed *= 1.1
        warn = False
    if ev.keyCode == 39:   # right arrow
        paddle.move("right")
        warn = False
    if ev.keyCode == 40:   # down arrow
        ball.dx /= 1.1
        ball.dy /= 1.1
        ball.speed /= 1.1
        ball.max_speed /= 1.1
        warn = False
    if ev.keyCode == 80:  # p or P for Pause
        pause = True
        info.write_help()
        if _id is not None: 
            clear_timeout(_id)
        warn = False
    elif ev.keyCode == 81:  # q or Q  for Quit
        doc.unbind("keydown")
        world.game_canvas.style.cursor = "default"
        world.clear_all()
        pause = True
        if _id is not None: 
            clear_timeout(_id)
        warn = False
    elif ev.keyCode == 83 and pause: # s or S for Start
        pause = False
        world.game_canvas.style.cursor = "none"
        world.clear_game()
        update()
        warn = False
    ev.preventDefault()
    if warn:
        notify("red")

    
def get_mouse_position(ev):
    bound = world.game_canvas.getBoundingClientRect()  
    x = ev.clientX - bound.left
    y = ev.clientY - bound.top
    return x, y
    
   
doc.bind("keydown", handle_keydown_events)

def update():
    '''update docstring'''
    global _id, pause, ball
    game_won = True
    world.clear_main()
    ball.move()
    ball.stay_in_world()
    if ball.overlaps_with(paddle):
        ball.handle_hit_with(paddle)
    for brick in bricks:
        if brick.is_hittable:
            game_won = False
            if ball.overlaps_with(brick):
                ball.handle_hit_with(brick)
                brick.handle_hit_with(ball)
        brick.draw()
    ball.draw()
    paddle.draw()
    if player.lost_life:
        if player.lives == 0:
            show_game_over()
        else:
            pause = True
            player.lost_life = False
            ball = Ball(10, world.height-30, dy=-5)
    score.draw()
    if game_won:
        info.show_game_win()
    if pause:
        info.write_help()
        return
    _id = set_timeout(update, tbf)
       
        
#---------------
DEBUG = False
pause = True
fps = 60     
tbf = 1000/fps   # time between frames in ms

ball = Ball(10, world.height-30, dy=-5)
paddle = Paddle(100, world.height-20)
doc.bind("mousemove", paddle.mouse_move)
bricks = [Brick(x, y) for x in range(30, 500, 90) for y in range(100, 350, 50)]
brick = Brick(200, 200)
world.clear_all()
world.draw_far_background()
info.write_help()