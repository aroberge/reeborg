from browser import doc, html
from math import pi
from browser.timer import set_timeout, clear_timeout

canvas = doc["game-canvas"]
ctx = canvas.getContext('2d')

class Ball(object):
    ''' ball docstring'''
    def __init__(self, x, y, radius=10, color='red', dx=5, dy=5):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
        self.dx = dx
        self.dy = dy
        self.calculate_bounding_box()
    
    def draw(self):
        ''' draw doc'''
        ctx.fillStyle = self.color
        ctx.beginPath()
        ctx.arc(self.x+self.radius, self.y+self.radius, self.radius, 0, pi*2)
        ctx.closePath()
        ctx.fill()        
     
    def move(self):
        self.x += self.dx
        self.y += self.dy

    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + 2*self.radius
        self.y_max = self.y + 2*self.radius
    
    def handle_hit_with(self, other):
        if isinstance(other, Paddle) and self.dy > 0:
            self.y -= self.dy
            self.dy = -self.dy
            offset = self.x - (paddle.x + paddle.width/2)
            self.dx = 10*offset/paddle.width
        elif isinstance(other, Brick):
            self.y -= self.dy
            self.dy = -self.dy
            
    def overlaps_with(self, other):
        if (    ((self.x_min < other.x_min < self.x_max ) or 
                 (other.x_min < self.x_min < other.x_max))
            and ((self.y_min < other.y_min < self.y_max) or 
                 (other.y_min < self.y_min < other.y_max)) ):
            return True
        return False 
        
    
    
class Paddle(object):
    
    def __init__(self, x, y, width=80, height=10, color="blue", dx=7):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.dx = dx
        self.calculate_bounding_box()
    
    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + self.width
        self.y_max = self.y + self.height
        
    def draw(self):
        ctx.fillStyle = self.color
        ctx.fillRect(self.x, self.y, self.width, self.height)

    def move(self, direction):
        if direction == "left":
            self.dx = - abs(self.dx)
        elif direction == "right":
            self.dx = abs(self.dx)
        self.x += self.dx
        keep_paddle_in()
        self.calculate_bounding_box()
    
    def mouse_move(self, ev):
        x, y = get_mouse_position(ev)
        self.x = x
        keep_paddle_in()
        self.calculate_bounding_box()
       
        
class Brick(object):
    
    def __init__(self, x, y, width=60, height=30, color="green"):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.color = color
        self.calculate_bounding_box()
        self.is_hittable = True
        self.is_visible = True
    
    def calculate_bounding_box(self):
        self.x_min = self.x
        self.y_min = self.y
        self.x_max = self.x + self.width
        self.y_max = self.y + self.height
        
    def draw(self):
        if self.is_visible:
            ctx.fillStyle = self.color
            ctx.fillRect(self.x, self.y, self.width, self.height)

    def handle_hit_with(self, other):
        if isinstance(other, Ball):
            self.is_visible = False
            self.is_hittable = False

def clear_screen():    
    ctx.clearRect(0, 0, canvas.width, canvas.height)
   
def write_help():
    ctx.font = "30px sans-serif"
    ctx.fillStyle = "lightgrey"
    ctx.fillText("S to start the animation", 50, 100)
    ctx.fillText("P to pause the animation", 50, 150)
    ctx.fillText("Q to quit: click BEFORE editing!", 50, 200)

def stay_in_world():
    if ball.x < 0 and ball.dx < 0:
        ball.dx = -ball.dx
        ball.x = -ball.x
    elif ball.x > canvas.width - 2*ball.radius and ball.dx > 0:
        ball.dx = -ball.dx
        ball.x = 2*(canvas.width - 2*ball.radius) - ball.x
    if ball.y < 0 and ball.dy < 0:
        ball.dy = -ball.dy
        ball.y =  -ball.y
    elif ball.y > canvas.height - 2*ball.radius and ball.dy > 0:
        if DEBUG:
            ball.dy = -ball.dy
            ball.y = 2*(canvas.height - 2*ball.radius) - ball.y
        else:
            game_over()
    ball.calculate_bounding_box()

def keep_paddle_in():
    if paddle.x < 0:
        paddle.x = 0
    elif paddle.x + paddle.width > canvas.width:
        paddle.x = canvas.width - paddle.width

def game_over():
    global pause
    pause = True
    ctx.font = "100px sans-serif"
    ctx.fillStyle = "red"
    ctx.fillText("Game over!", 50, 300)

def game_win():
    global pause
    pause = True
    ctx.font = "100px sans-serif"
    ctx.fillStyle = "green"
    ctx.fillText("You win!", 50, 300)            
            
def handle_keydown_events(ev):
    global pause, _id
    _id = None
    warn = True
    if ev.keyCode == 37:   # left arrow
        paddle.move("left")
        warn = False
    if ev.keyCode == 39:   # right arrow
        paddle.move("right")
        warn = False
    if ev.keyCode == 80:  # p or P for Pause
        pause = True
        if _id is not None: 
            clear_timeout(_id)
        warn = False
    elif ev.keyCode == 81:  # q or Q  for Quit
        doc.unbind("keydown")
        canvas.style.cursor = "default"
        clear_screen()
        pause = True
        if _id is not None: 
            clear_timeout(_id)
        warn = False
    elif ev.keyCode == 83 and pause: # s or S for Start
        pause = False
        canvas.style.cursor = "none"
        update()
        warn = False
    ev.preventDefault()
    if warn:
        notify("red")

    
def get_mouse_position(ev):
    bound = canvas.getBoundingClientRect()  
    x = ev.clientX - bound.left
    y = ev.clientY - bound.top
    return x, y
    
   
doc.bind("keydown", handle_keydown_events)

def update():
    '''update docstring'''
    global _id
    global game_won = True
    clear_screen()
    ball.move()
    stay_in_world()
    write_help()
    if ball.overlaps_with(paddle):
        ball.handle_hit_with(paddle)
    for brick in bricks:
        if brick.is_hittable:
            game_won = False
            if ball.overlaps_with(brick):
                ball.handle_hit_with(brick)
                brick.handle_hit_with(ball)
        brick.draw()
    ball.draw()
    paddle.draw()
    if game_won:
        game_win()
    if pause:
        return
    _id = set_timeout(update, tbf)
       
        
#---------------
DEBUG = False
pause = True
fps = 60     
tbf = 1000/fps   # time between frames in ms

ball = Ball(10, canvas.height-30, dy=-5)
paddle = Paddle(100, canvas.height-20)
doc.bind("mousemove", paddle.mouse_move)
bricks = [Brick(x, y) for x in range(30, 500, 90) for y in range(100, 350, 50)]
brick = Brick(200, 200)
clear_screen()
write_help()